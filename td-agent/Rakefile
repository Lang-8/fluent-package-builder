#!/usr/bin/env rake

require_relative '../lib/package-task'
require_relative '../lib/gems_parser'
require_relative 'config.rb'
require 'rake/testtask'
require 'rake/clean'
require 'erb'
require 'shellwords'
require 'pathname'
require 'open-uri'
require 'digest'
require 'etc'

DOWNLOADS_DIR  = File.expand_path(ENV["TD_AGENT_DOWNLOADS_PATH"] || "downloads")
STAGING_DIR    = File.expand_path(ENV["TD_AGENT_STAGING_PATH"]   || "staging")

CLEAN.include(STAGING_DIR)
CLOBBER.include(DOWNLOADS_DIR)

# Debian
CLEAN.include("apt/tmp")
CLEAN.include("apt/build.sh")
CLEAN.include("apt/env.sh")
CLEAN.include("debian/tmp")
CLOBBER.include("apt/repositories")

# Red Hat
CLEAN.include("yum/tmp")
CLEAN.include("yum/build.sh")
CLEAN.include("yum/env.sh")
CLOBBER.include("yum/repositories")

# Windows
CLEAN.include("msi/env.bat")
CLEAN.include("msi/parameters.wxi")
CLEAN.include("msi/project-files.wxs")
CLEAN.include("msi/*.wixobj")
CLEAN.include("msi/*.wixpdb")
CLOBBER.include("msi/*.msi")

def windows?
  GemsParser.windows?
end

def ensure_directory(dirname)
  mkdir_p(dirname) unless File.exists?(dirname)
  if block_given?
    cd(dirname) do
      yield
    end
  end
end

class DownloadTask
  include Rake::DSL

  attr_reader :file_ruby_source, :file_ruby_installer_x64

  def files
    [
      @file_ruby_source,
      @file_ruby_installer_x64,
      *@files_core_gems,
      *@files_plugin_gems
    ]
  end

  def define
    define_ruby_files
    define_gem_files("core_gems")
    define_gem_files("plugin_gems")

    namespace :download do
      desc "Download Ruby source"
      task :ruby => [@file_ruby_source, @file_ruby_installer_x64]

      desc "Download core_gems"
      task :core_gems => @files_core_gems

      desc "Download plugin_gems"
      task :plugin_gems => @files_plugin_gems

      desc "Clone fluentd repository"
      task :fluentd do
        ensure_directory(DOWNLOADS_DIR) do
          remove_dir("fluentd", true) if File.exists?("fluentd")
          sh("git", "clone", "https://github.com/fluent/fluentd.git")
        end
      end
    end
  end

  private

  def download_file(url, filename, sha256sum = nil)
    tmp_filename = "#{filename}.part"

    ensure_directory(DOWNLOADS_DIR) do
      puts "Downloading #{filename}..."
      open(url) do |in_file|
        open(tmp_filename, "wb") do |out_file|
          out_file.write(in_file.read)
        end
      end

      unless sha256sum.nil?
        digest = Digest::SHA256.file(tmp_filename)
        fail "Downloaded #{tmp_filename} is broken!!!" if digest != sha256sum
      end

      mv(tmp_filename, filename)
    end
  end

  def define_ruby_files
    define_ruby_source_file
    define_ruby_installer_file
  end

  def define_ruby_source_file
    version = BUNDLED_RUBY_VERSION
    sha256sum = BUNDLED_RUBY_SOURCE_SHA256SUM
    filename = "ruby-#{version}.tar.gz"
    feature_version = version.match(/^(\d+\.\d+)/)[0]
    url_base = "https://cache.ruby-lang.org/pub/ruby/"
    url = "#{url_base}#{feature_version}/#{filename}"

    @file_ruby_source = File.join(DOWNLOADS_DIR, filename)

    file @file_ruby_source do
      download_file(url, filename, sha256sum)
    end
  end

  def define_ruby_installer_file
    version = BUNDLED_RUBY_VERSION
    release = BUNDLED_RUBY_INSTALLER_X64_RELEASE
    sha256sum = BUNDLED_RUBY_INSTALLER_X64_SHA256SUM
    filename = "rubyinstaller-#{version}-#{release}-x64.7z"
    url_base = "https://github.com/oneclick/rubyinstaller2/releases/download/"
    url = "#{url_base}RubyInstaller-#{version}-#{release}/#{filename}"

    @file_ruby_installer_x64 = File.join(DOWNLOADS_DIR, filename)

    file @file_ruby_installer_x64 do
      download_file(url, filename, sha256sum)
    end
  end

  def define_gem_files(category)
    paths = []
    gems_parser = GemsParser.parse(File.read("#{category}.rb"))
    digits = (gems_parser.target_files.length - 1).to_s.length
    target_dir = File.join(DOWNLOADS_DIR, gems_parser.target_dir)

    gems_parser.target_files.each_with_index do |target, index|
      name, version = target
      gem = "#{name}-#{version}.gem"
      numbered_gem = sprintf("%0#{digits}d-%s", index, gem)
      path = File.join(target_dir, numbered_gem)
      paths << path

      file path do
        ensure_directory(target_dir) do
          if version.include?("-")
            version_option = ["--version", "#{version.sub(/\-.*/, '')}"]
          else
            version_option = ["--version", "#{version}", "--platform", "ruby"]
          end
          gem = "#{name}-#{version}.gem"
          numbered_gem = sprintf("%0#{digits}d-%s", index, gem)
          sh("gem", "fetch", "#{name}", *version_option)
          `gem install --explain #{gem} --no-document`
          fail "Failed to download #{gem}!" unless $?.success?
          mv("#{gem}", "#{numbered_gem}")
        end
      end
    end

    instance_variable_set("@files_#{category}", paths)
  end
end

class BuildTask
  include Rake::DSL

  GEM_INSTALL_DIR = File.join("#{STAGING_DIR}", "opt", "#{PACKAGE_NAME}")

  def initialize(download_task)
    @download_task = download_task
  end

  def define
    namespace :build do
      desc "Install Ruby"
      task :ruby => [:"download:ruby"] do
        if windows?
          extract_ruby_installer
        else
          build_ruby_from_source
        end
      end

      desc "Install core_gems"
      task :core_gems => [:"download:core_gems", :ruby] do
        ensure_directory(GEM_INSTALL_DIR)
        pattern = File.join(DOWNLOADS_DIR, 'core_gems', '*.gem')
        Dir.glob(File.expand_path(pattern)).sort.each do |gem_path|
          gem_install(gem_path)
        end
      end

      desc "Install plugin_gems"
      task :plugin_gems => [:"download:plugin_gems", :fluentd] do
        ensure_directory(GEM_INSTALL_DIR)
        pattern = File.join(DOWNLOADS_DIR, 'plugin_gems', '*.gem')
        Dir.glob(File.expand_path(pattern)).sort.each do |gem_path|
          gem_install(gem_path)
        end
      end

      desc "Install fluentd"
      task :fluentd => [:"download:fluentd", :core_gems] do
        ensure_directory(GEM_INSTALL_DIR)
        revision = FLUENTD_REVISION
        cd(File.join(DOWNLOADS_DIR, "fluentd")) do
          sh("git", "checkout", "-b", "#{PACKAGE_NAME}-#{PACKAGE_VERSION}", "#{revision}") if revision
          sh("rake", "build")
          gem_install("pkg/fluentd-*.gem")
        end
      end

      desc "Install all gems"
      task :gems => [:plugin_gems]

      debian_pkg_scripts = ["preinst", "postinst", "prerm", "postrm"]
      debian_pkg_scripts.each do |script|
        CLEAN.include(File.join("debian", script))
      end

      desc "Create debian package script files from template"
      task :deb_scripts do
        # copy pre/post scripts into "debian" directory
        debian_pkg_scripts.each do |script|
          src = template_path('package-scripts', 'td-agent', "deb", script)
          next unless File.exist?(src)
          dest = File.join("debian", File.basename(script))
          render_template(dest, src, template_config, { mode: 0755 })
        end
      end

      desc "Create td-agent configuration files from template"
      task :td_agent_config do
        conf_paths = [
          ['td-agent', 'td-agent.conf'],
          ['td-agent', 'td-agent.conf.tmpl'],
          ['logrotate.d', 'td-agent.logrotate']
        ]
        conf_paths.each do |item|
          src = template_path('etc', *item)
          dest = File.join(STAGING_DIR, 'etc', *item)
          render_template(dest, src, template_config)
        end
      end

      desc "Create sbin script files from template"
      task :sbin_scripts do
        ["td-agent", "td-agent-gem"].each do |command|
          src = template_path('usr', 'sbin', "#{command}.erb")
          dest = File.join(STAGING_DIR, 'usr', 'sbin', command)
          render_template(dest, src, template_config, { mode: 0755 })
        end
      end

      desc "Create systemd unit file for Red Hat like systems"
      task :rpm_systemd do
        dest =  File.join(STAGING_DIR, 'usr', 'lib', 'systemd', 'system', PACKAGE_NAME + ".service")
        params = {pkg_type: "rpm"}
        render_systemd_unit_file(dest, template_config(params))
      end

      desc "Create systemd unit file for Debian like systems"
      task :deb_systemd do
        dest = File.join(STAGING_DIR, 'etc', 'systemd', 'system', PACKAGE_NAME + ".service")
        params = {pkg_type: "deb"}
        render_systemd_unit_file(dest, template_config(params))
      end

      desc "Create config files for WiX Toolset"
      task :wix_config do
        src  = File.join('msi', 'parameters.wxi.erb')
        dest = File.join('msi', 'parameters.wxi')
        render_template(dest, src, template_config)
      end

      desc "Create configuration files for Red Hat like systems"
      task :rpm_config => [:td_agent_config, :sbin_scripts, :rpm_systemd]

      desc "Create configuration files for Debian like systems"
      task :deb_config => [:td_agent_config, :sbin_scripts, :deb_systemd, :deb_scripts]

      desc "Create configuration files for Windows"
      task :msi_config => [:td_agent_config, :sbin_scripts, :wix_config]
    end
  end

  private

  def template_config(params = nil)
    config = {
      project_name: PACKAGE_NAME,
      version: PACKAGE_VERSION,
      install_path: nil,
      install_message: nil,
      root_path: "/", # for systemd unit file
      pkg_type: nil,
    }

    if windows?
      # "default_root" is defined in omnibus, and it's used in
      # omnibus-td-agent/config/projects/td-agent3.rb.
      # To avoid confusion, we use same default_root value with omnibus.
      default_root = "C:"
      config[:install_path] = File.join("#{default_root}", "opt", "#{PACKAGE_NAME}")
    else
      default_root = "/opt"
      config[:install_path] = File.join("#{default_root}", "#{PACKAGE_NAME}")
    end

    if params
      config.merge(params)
    else
      config
    end
  end

  def template_path(*path_parts)
    File.join('templates', *path_parts)
  end

  def render_template(dest, src, config, opts={})
    erb_binding = binding
    config.each do |key, value|
      erb_binding.local_variable_set(key, value)
    end

    destination = dest.gsub('td-agent', config[:project_name])
    directory = File.dirname(destination)
    mode = opts.fetch(:mode, 0644)

    puts "Generate #{destination}"
    ensure_directory(directory)
    File.open(destination, 'w', mode) do |f|
      template = ERB.new(File.read(src), nil, '<>')
      f.write(template.result(erb_binding))
    end
  end

  def render_systemd_unit_file(dest_path, config)
    template_file_path = template_path('etc', 'systemd', 'td-agent.service.erb')
    render_template(dest_path, template_file_path, config, { mode: 0755 })
  end

  def build_ruby_from_source
    tarball = @download_task.file_ruby_source
    ruby_source_dir = tarball.sub(/\.tar\.gz$/, '')

    sh("tar", "xvf", tarball, "-C", DOWNLOADS_DIR)

    configure_opts = [
      "--enable-shared",
      "--prefix=/opt/#{PACKAGE_NAME}/embedded",
      "--disable-install-doc",
    ]
    cd(ruby_source_dir) do
      sh("./configure #{configure_opts.join(' ')}")
      sh("make", "install", "-j#{Etc.nprocessors}", "DESTDIR=#{STAGING_DIR}")

      # For building gems. The built ruby & gem command cannot use without install.
      sh("make", "install")
    end
  end

  def extract_ruby_installer
    ensure_directory(GEM_INSTALL_DIR) do
      path = File.expand_path(@download_task.file_ruby_installer_x64)
      src_dir = File.basename(path).sub(/\.7z$/, '')
      dest_dir = "embedded"

      rm_rf(dest_dir)
      sh("7z",
         "x",    # Extract files with full paths
         "-y",   # Assume yes on all queries
         "-aoa", # Overwrite all existing files without prompt
         path)
      mv(src_dir, dest_dir)
    end
  end

  def gem_install(gem_path)
    if windows?
      # TODO: Setup build env for native extensions
      gem_command = "gem"
    else
      gem_command = "/opt/#{PACKAGE_NAME}/embedded/bin/gem"
    end

    sh("#{gem_command}", "install",
       "--no-document",
       "--install-dir", "#{GEM_INSTALL_DIR}",
       "#{gem_path}")
  end
end

class LinuxPackageTask < PackageTask
  def initialize(download_task)
    @download_task = download_task
    super(PACKAGE_NAME, PACKAGE_VERSION, detect_release_time)
    @archive_tar_name = "#{@package}-#{@version}.tar"
    @archive_name = "#{@archive_tar_name}.gz"
    CLEAN.include(@archive_name)
  end

  private

  def define_archive_task
    repo_files = `git ls-files --full-name`.split("\n").collect do |path|
      File.join("..", "#{path}")
    end

    file @archive_name => [*repo_files, *@download_task.files]  do
      build_archive
    end
  end

  def build_archive
    cd("..") do
      sh("git", "archive", "HEAD",
         "--prefix", "#{@archive_base_name}/",
         "--output", @full_archive_name)
      sh("tar", "xvf", @full_archive_name)
      @download_task.files.each do |path|
        src_path = Pathname(path)
        dest_path = Pathname(DOWNLOADS_DIR)
        relative_path = src_path.relative_path_from(dest_path)
        dest_downloads_dir = "#{@archive_base_name}/td-agent/downloads"
        dest_dir = "#{dest_downloads_dir}/#{File.dirname(relative_path)}"
        ensure_directory(dest_dir)
        cp_r(path, dest_dir)
      end
      sh("tar", "cvfz", @full_archive_name, "#{@archive_base_name}")
      rm_rf("#{@archive_base_name}")
    end
  end

  def apt_targets_default
    [
      "debian-buster",
      "ubuntu-bionic",
    ]
  end

  def yum_targets_default
    [
      "centos-7",
      "centos-8",
    ]
  end

  private
  def detect_release_time
    release_time_env = ENV["TD_AGENT_RELEASE_TIME"]
    if release_time_env
      Time.parse(release_time_env).utc
    else
      Time.now.utc
    end
  end
end

class WindowsPackageTask
  include Rake::DSL

  MSI_OUTPUT_DIR = ENV["TD_AGENT_MSI_OUTPUT_PATH"] || "."

  def initialize
    @package = PACKAGE_NAME
    @version = PACKAGE_VERSION
    @staging_dir = STAGING_DIR
  end

  def define
    namespace :msi do
      desc "Build MSI package (alias for msi:selfbuild)"
      task :build do
        Rake::Task["msi:selfbuild"].invoke
      end

      desc "Build MSI package"
      task :selfbuild => [:"build:msi_config", :"build:gems"] do
        run_build
      end

      desc "Build MSI package by Docker"
      task :dockerbuild => ["#{PACKAGE_NAME}-#{PACKAGE_VERSION}.tar.gz"] do
        run_docker("windows", arch)
      end
    end
  end

  private

  def run_build
    cd("msi") do
      # Pick up package contents
      sh(heat_path,
         "dir", @staging_dir,
         "-nologo", # Skip heat logo
         "-srd",    # Suppress harvesting the root directory as an element
         "-sreg",   # Suppress registry harvesting
         "-gg",                          # Generate guides
         "-cg", "ProjectDir",            # Component Group Name
         "-dr", "PROJECTLOCATION",       # Root directory reference
         "-var", "var.ProjectSourceDir", # Substitue File/@Source="SourceDir"
         "-t",   "exclude-files.xslt",   # XSLT for exclude files
         "-out", 'project-files.wxs')

      # Build
      sh(candle_path,
         "-nologo",                            # Skip candle logo
         "-dProjectSourceDir=#{@staging_dir}", # Define a parameter
         "project-files.wxs",
         "source.wxs")

      # Link
      sh(light_path,
         "-nologo",                        # Skip light logo
         "-ext", "WixUIExtension",         # Extension assembly
         "-cultures:en-us",                # Localization
         "-loc", "localization-en-us.wxl", # Localization file
         "project-files.wixobj",
         "source.wixobj",
         "-out", File.join(MSI_OUTPUT_DIR, "#{@package}-#{@version}-#{arch}.msi"))
    end
  end

  def write_env
    env_bat = "msi/env.bat"
    File.open(env_bat, "w") do |file|
      file.puts(<<-ENV)
SET PACKAGE=#{@package}
SET VERSION=#{@version}
SET ARCH=#{arch}
      ENV
    end
  end

  # TODO: Unify with PackageTask
  def run_docker(os, architecture=nil)
    top_dir = File.expand_path('../.')
    id = os
    id = "#{id}-#{architecture}" if architecture
    docker_tag = "#{@package}-#{id}"
    build_command_line = [
      "docker",
      "build",
      "--tag", docker_tag,
    ]
    run_command_line = [
      "docker",
      "run",
      "--rm",
      "--tty",
      "--volume", "#{top_dir}:c:/td-agent-builder:rw",
    ]
    docker_context = "msi"
    build_command_line << docker_context
    run_command_line.concat([docker_tag, 'c:\td-agent-builder\td-agent\msi\build.bat'])

    write_env

    sh(*build_command_line)
    sh(*run_command_line)
  end

  def windows_path(*pieces)
    path = File.join(*pieces)
    if File::ALT_SEPARATOR
      path.gsub(File::SEPARATOR, File::ALT_SEPARATOR)
    else
      path
    end
  end

  def wix_dir
    dir = ENV["WIX"]
    fail "Can't find WiX commands path" if dir.nil? || dir.empty?
    dir
  end

  def wix_bin_dir
    windows_path(wix_dir, "bin")
  end

  def heat_path
    windows_path(wix_bin_dir, "heat")
  end

  def candle_path
    windows_path(wix_bin_dir, "candle")
  end

  def light_path
    windows_path(wix_bin_dir, "light")
  end

  def arch
    if RUBY_PLATFORM =~ /x64/
      "x64"
    elsif RUBY_PLATFORM =~ /i386/
      "x86"
    else
      fail "Unknown platform: #{RUBY_PLATFORM}"
    end
  end
end

download_task = DownloadTask.new
download_task.define

build_task = BuildTask.new(download_task)
build_task.define

linux_package_task = LinuxPackageTask.new(download_task)
linux_package_task.define

windows_package_task = WindowsPackageTask.new
windows_package_task.define
