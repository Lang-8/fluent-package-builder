#!/usr/bin/env rake
require_relative '../lib/td-agent-package-task'
require_relative '../lib/gems_parser'
require 'fileutils'
require 'rake/testtask'
require 'rake/clean'
require 'erb'
require 'shellwords'

def windows?
  RUBY_PLATFORM =~ /mswin|mingw/
end

version = "3.5.1"
package_name = "td-agent"

staging_path = ENV["TD_AGENT_STAGING_PATH"] || "staging"
git_workspace = "git/fluentd"
if windows?
  default_root = "C:"
  install_path = File.join("#{default_root}", "opt", "#{package_name}")
  gem_install_dir = File.join("#{staging_path}", "opt", "#{package_name}")
  upgrade_code = "76dcb0b2-81ad-4a07-bf3b-1db567594171"
else
  default_root = "/opt"
  install_path = File.join("#{default_root}", "#{package_name}")
  gem_install_dir = File.join("#{staging_path}", "#{install_path}")
end
install_message = nil

CLEAN.include(staging_path)

# Debian
CLEAN.include("apt/tmp")
CLEAN.include("apt/build.sh")
CLEAN.include("apt/env.sh")
CLEAN.include("debian/tmp")
CLOBBER.include("apt/repositories")

# Red Hat
CLEAN.include("yum/tmp")
CLEAN.include("yum/build.sh")
CLEAN.include("yum/env.sh")
CLOBBER.include("yum/repositories")

# Windows
CLEAN.include("msi/parameters.wxi")
CLEAN.include("msi/project-files.wxs")
CLEAN.include("msi/*.wixobj")
CLEAN.include("msi/*.wixpdb")
CLOBBER.include("msi/*.msi")

namespace :download do
  desc "Download core_gems"
  task :core_gems do
    download_gems("core_gems.rb")
  end

  desc "Clone fluentd repository"
  task :fluentd do
    revision = nil
    mkdir_p git_workspace
    cd git_workspace do
      sh("git", "clone", "https://github.com/fluent/fluentd.git") unless File.exists?("fluentd")
    end
  end

  desc "Download plugin_gems"
  task :plugin_gems do
    download_gems("plugin_gems.rb")
  end

  def download_gems(gems_path)
    gems_parser = GemsParser.parse(File.read(gems_path))
    digits = (gems_parser.target_files.length - 1).to_s.length

    FileUtils.remove_dir(gems_parser.target_dir, true)
    Dir.mkdir(gems_parser.target_dir)
    Dir.chdir(gems_parser.target_dir) do
      gems_parser.target_files.each_with_index do |target, index|
        name, version = target
        if version.include?("-")
          version_option = ["--version", "#{version.sub(/\-.*/, '')}"]
        else
          version_option = ["--version", "#{version}", "--platform", "ruby"]
        end
        gem = "#{name}-#{version}.gem"
        numbered_gem = sprintf("%0#{digits}d-%s", index, gem)
        sh("gem", "fetch", "#{name}", *version_option)
        `gem install --explain #{gem} --no-document`
        fail "Failed to download #{gem}!" unless $?.success?
        FileUtils.mv("#{gem}", "#{numbered_gem}")
        sleep 1
      end
    end
  end
end

namespace :build do
  desc "Install core_gems"
  task :core_gems => :"download:core_gems" do
    Dir.glob(File.expand_path(File.join(__dir__, 'core_gems', '*.gem'))).sort.each { |gem_path|
      sh("gem", "install", "--no-document", "#{gem_path}", "--install-dir", "#{gem_install_dir}")
    }
  end

  desc "Install fluentd"
  task :fluentd => [:"download:fluentd", :core_gems] do
    revision = nil
    cd git_workspace do
      cd "fluentd" do
        sh("git", "checkout", "#{revision}") if revision
        sh("rake", "build")
        sh("gem", "install", "--no-document", "pkg/fluentd-*.gem", "--install-dir", "#{gem_install_dir}")
      end
    end
  end

  desc "Install plugin_gems"
  task :plugin_gems => [:"download:plugin_gems", :fluentd] do
    Dir.glob(File.expand_path(File.join(__dir__, 'plugin_gems', '*.gem'))).sort.each { |gem_path|
      sh("gem", "install", "--no-document", "#{gem_path}", "--install-dir", "#{gem_install_dir}")
    }
  end

  desc "Install all gems"
  task :gems => [:plugin_gems]

  def template_path(*path_parts)
    File.join('templates', *path_parts)
  end

  def generate_from_template(dest, src, erb_binding, opts={})
    mode = opts.fetch(:mode, 0644)
    package_name = erb_binding.local_variable_get(:package_name)
    destination = dest.gsub('td-agent', package_name)
    FileUtils.mkdir_p(File.dirname(destination))
    File.open(destination, 'w', mode) do |f|
      f.write ERB.new(File.read(src), nil, '<>').result(erb_binding)
    end
  end

  def generate_systemd_unit_file(dest_path, erb_binding, opts={})
    template_file_path = template_path('etc', 'systemd', 'td-agent.service.erb')
    if File.exist?(template_file_path)
      generate_from_template(dest_path, template_file_path, erb_binding, { mode: 0755 })
    end
  end

  debian_pkg_scripts = ["preinst", "postinst", "prerm", "postrm"]
  debian_pkg_scripts.each do |script|
    CLEAN.include(File.join("debian", script))
  end

  desc "Create debian package script files from template"
  task :deb_scripts do
    # copy pre/post scripts into "debian" directory
    debian_pkg_scripts.each do |script|
      src = template_path('package-scripts', 'td-agent', "deb", script)
      next unless File.exist?(src)
      dest = File.join("debian", File.basename(script))
      generate_from_template(dest, src, binding, { mode: 0755 })
    end
  end

  desc "Create td-agent configuration files from template"
  task :td_agent_config do
    conf_paths = [
      ['td-agent', 'td-agent.conf'],
      ['td-agent', 'td-agent.conf.tmpl'],
      ['logrotate.d', 'td-agent.logrotate']
    ]
    conf_paths.each { |item|
      src = template_path('etc', *item)
      dest = File.join(staging_path, 'etc', *item)
      generate_from_template(dest, src, binding)
    }
  end

  desc "Create sbin script files from template"
  task :sbin_scripts do
    ["td-agent", "td-agent-gem"].each { |command|
      src = template_path('usr', 'sbin', "#{command}.erb")
      dest = File.join(staging_path, 'usr', 'sbin', command)
      generate_from_template(dest, src, binding, { mode: 0755 })
    }
  end

  desc "Create systemd unit file for Red Hat like systems"
  task :rpm_systemd do
    pkg_type = "rpm"
    root_path = "/"
    dest =  File.join(staging_path, 'usr', 'lib', 'systemd', 'system', package_name + ".service")
    generate_systemd_unit_file(dest, binding)
  end

  desc "Create systemd unit file for Debian like systems"
  task :deb_systemd do
    pkg_type = "deb"
    root_path = "/"
    dest = File.join(staging_path, 'etc', 'systemd', 'system', package_name + ".service")
    generate_systemd_unit_file(dest, binding)
  end

  desc "Create config files for WiX Toolset"
  task :wix_config do
    src  = File.join('msi', 'parameters.wxi.erb')
    dest = File.join('msi', 'parameters.wxi')
    generate_from_template(dest, src, binding)
  end

  desc "Create configuration files for Red Hat like systems"
  task :rpm_config => [:td_agent_config, :sbin_scripts, :rpm_systemd]

  desc "Create configuration files for Debian like systems"
  task :deb_config => [:td_agent_config, :sbin_scripts, :deb_systemd, :deb_scripts]

  desc "Create configuration files for Windows"
  task :msi_config => [:td_agent_config, :sbin_scripts, :wix_config]

  desc "Build MSI package"
  task :msi => [:msi_config, :gems] do
    wix_dir = ENV["WIX"]
    fail "Can't find WiX commands path" if wix_dir.empty?

    wix_bin_dir = File.join(wix_dir, "bin")
    heat_path = File.join(wix_bin_dir, "heat")
    candle_path = File.join(wix_bin_dir, "candle")
    light_path = File.join(wix_bin_dir, "light")

    if RUBY_PLATFORM =~ /x64/
      arch = "x64"
    elsif RUBY_PLATFORM =~ /i386/
      arch = "x86"
    else
      fail "Unknown platform: #{RUBY_PLATFORM}"
    end

    Dir.chdir("msi") do
      staging_dir = File.join("..", staging_path)

      # Pick up package contents
      sh(heat_path,
         "dir", staging_dir,
         "-nologo", # Skip heat logo
         "-srd",    # Suppress harvesting the root directory as an element
         "-sreg",   # Suppress registry harvesting
         "-gg",                          # Generate guides
         "-cg", "ProjectDir",            # Component Group Name
         "-dr", "PROJECTLOCATION",       # Root directory reference
         "-var", "var.ProjectSourceDir", # Substitue File/@Source="SourceDir"
         "-t",   "exclude-files.xslt",   # XSLT for exclude files
         "-out", 'project-files.wxs')

      # Build
      sh(candle_path,
         "-nologo",                           # Skip candle logo
         "-dProjectSourceDir=#{staging_dir}", # Define a parameter
         "project-files.wxs",
         "source.wxs")

      # Link
      sh(light_path,
         "-nologo",                        # Skip light logo
         "-ext", "WixUIExtension",         # Extension assembly
         "-cultures:en-us",                # Localization
         "-loc", "localization-en-us.wxl", # Localization file
         "project-files.wixobj",
         "source.wixobj",
         "-out", "td-agent-#{version}-#{arch}.msi")
    end
  end
end

task = TDAgentPackageTask.new(package_name, version)
task.define
